# time_series_accelerator
Кратко:

Есть вот такой сайт https://n0thingsp3zial.github.io/webshit/ (открывать с телефона), который собирает жест – данные с гироскопа и акселерометра телефона. Нужно сделать продвинутую версию с бекендом.

Более детально:

Данные, которые собираются представляют из себя временной ряд – 6 float-массивов длины n (n >= 0). Откуда 6: 3 оси акселерометра и 3 оси гироскопа. Для удобства эти массивы конвертируются в json.

У меня есть фронтенд часть, которая занимается сбором временных рядов и классификатор этих самых временных рядов. Нужно написать сайт, который реализует 2 пользовательких сценария:

1) Обучение: пользователь вводит свой логин (мб пароль еще?), записывает свой жест (в этот момент снимаются показания датчиков и собирается json-файлик), файлик отправляется в хранилище

2) Аутентификация: пользователь вводит логин, записывает жест, файлик отправялется на бек, где происходит парсинг json'ки и классификация, в результате которой скрипт выдает 1 (ок) или 0 (не ок). Результат аутентификации видит пользователь (желательно еще сохранять отдельно попытки аутетификации)



Хотелка #1: возможность настраивать частоту сбора данных (на разных телефонах датчики разные и разная частота их работа - надо унифицировать) и количество примеров для обучения (для экспериментов). Можно вынести в отдельный раздел а-ля "настройки"


Хотелка #2: реализовать в виде веб-приложения (чтобы все происходило без перезагрузки страницы)


есть 2 пользовательских сценария. чтобы их различать я бы встроил toggle switch: один режим называется train, другой test

Первый сценарий (положение toggle switch в train):
на стартовом экране видно только поле name (gesture стоит убрать), куда он вводит свой никнейм. далее переход на экран с графикам - тут происходит сбор данных с датчиков (уже реализованно). после нажатия на стоп также появляются кнопки back и upload (вместо download, которая сейчас). Если back - возврат на экран с toggle switch. Если upload - получившийся временной ряд нужно добавить в базу данных для заданого name (никнейма пользователя). Если загрузка прошла успешно - возвращаем пользователю на фронт что-то вроде success (ответ на запрос). и перекидываем на экран со toggle switch

Второй сценарий (toggle switch в положении test):
тут уже есть поля ‘name to attack’ и ‘name’ - их пользователь заполняет и опять переходит на окно со сбором (там где графики). После нажатия стоп появляются так же две кнопки: back - возвращаемся на экран с toggle switch, test - по нажатию отправляется на бэк, где для заданого ‘name to attack’ подгружаются из бд N временных рядов (N настраивается отдельно - поэтому нужно добавить где-то это настройку вместе с частотой обновления eventListener, чтобы менять частоту обращения к датчикам), после чего из них формируется матрица размера Nx6xLength (N - количество примеров для обучения (если в бд меньше - выкидываем сообщение пользователю об этом и возвращаем в начало), 6 - 3 ост акселерометра и 3 оси гироскопа, Lenght - длинна временного ряда) и от этой матрицы вызывается что то вроде model.fit(X_train) - мой скрипт, а затем вызывается model.predict(X_test), где Х_test - временной ряд, полученный в результате сбор (который мы и отправили на тестирование). predict возвращает либо 0, либо 1 - если 0, то возвращаем на фронт пользователю fail, если 1 - success и выкидываем на начальный экран. При этом в отдельную таблицу (а-ля attackers) сохраняем полученный временной ряд для ‘name’ - второго поля, которое мы добавили специально для этого.

нужно сделать это и настройку конфига (примеры для обучения и частота сбора). 
настройка кон фиша имеет наименьший приоритет, поэтому лучше сосредоточиться именно на сценариях


первый сценарий после пост запроса перекинуть юзера обратно на старт

второй сценарий после того как json отправили на бэк
где от нее будет вызываться некая питон функция нужно чтобы был подготовлен массив
он будет 3D массив, samples_count
две переменные к моменту вызова скрипта X_train содержит samples_count * длину временных рядов (6)
[
    samples_count => [
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
    ],
    [
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
    ],
    [
        [1,2,3,4,5,6],
        [1,2,3,4,5,6],
    ],
]
X_test длину временных рядов (6)
[
    [1,2,3,4,5,6],
    [1,2,3,4,5,6],
] (длина временного ряда)